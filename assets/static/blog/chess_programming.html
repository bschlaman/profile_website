<!DOCTYPE html>
<html>
<head>
	<!-- metas -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="Brendan Schlaman">

	<!-- css, favicon, title -->
	<link rel="stylesheet" type="text/css" href="/blog/styles.css">
	<link rel="icon" type="image/png" href="/favicon.png" />
	<title>Brendan Schlaman | Blog</title>

	<!-- highlight.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/a11y-dark.min.css">
	<script>hljs.highlightAll();</script>
</head>
<body><!-- workaround for FOUC --><script>let FF_FOUC_FIX;</script>
<div class="wrapper">
<header>
	<div class="intro">
		<h1>Chess Programming</h1>
		<a href="https://www.schlamalama.com"><img src="/media/brendan_piano.jpeg"/></a>
		<p class="name">Brendan Schlaman</p>
		<p class="date-time">June 3, 2021</p>
	</div>
	<h2>Essays:</h2>
	<ul>
		<li class="li-active"><a href="/chess_programming">Chess Programming</a></li>
		<li><a href="/cryptography">Cryptography</a></li>
		<li><a href="/zkp">Zero Knowledge Proofs</a></li>
	</ul>
</header>
<main>
	<h3>Topic: Efficient Move Generation for my Engine</h3>
	<p class="date-time">May 30, 2021</p>
	<h4>Goals</h4>
		<ul>
			<li>improve the performance of my perft</li>
			<li>explore other board representations</li>
		</ul>
		<p>My engine currently uses a 10x12 representation, which is the smallest setup that uses piece offsets with OFFBOARD checks.</p>
		<h4>Dissecting qperft.c</h4>
		<p>The memory location for the board seems to be the board itself plus capture codes and a delta vector (whatever that is).</p>
		<pre><code class="lang-c">
#define board      (brd+1)                /* 12 x 16 board: dbl guard band */
#define capt_code  (brd+1+0xBC+0x77)      /* piece type that can reach this*/
#define delta_vec  ((char *) brd+1+0xBC+0xEF+0x77) /* step to bridge certain vector */
		</code></pre>
		<p>Ignoring for now that <code>brd</code> starts earlier than <code>board</code>, the board has a length of <code>0xBC + 0x77 = 0x133</code> or <code>188 + 119 = 307</code>.  The comments in the code indicate that it is a 12 x 16 board representation, but that only comes out to a size of 192.  What's more, following the 0x88 style, only the first 185 or 186 squares are useful (depending on where the board is placed within the guard squares).</p>
		<p>The next clue is in the <code>board_init</code> function.</p>
		<pre><code class="lang-c">
for(i= -1; i&lt;0xBC; i++) b[i] = (i-0x22)&amp;0x88 ? GUARD : DUMMY;
		</code></pre>
		<p>So it appears that the 0xBC portion of the board houses the actual squares.  0x88 shows up here to determine if the square is offboard.  The advantage of an 0x88 board representation is that the 16ths place nibble represents the rank, and the 1s place nibble represents the file.  This means taking the bitwise &amp; operator with a square and 0x88 (1000 1000<sub>2</sub>) will determine if it is OFFBOARD.</p>
		<p>There is also an offset of 0x22 here, which indicates that there are two rows of 16 guard squares +2 on the 3rd row.  Using the following code, I've printed the resulting board:</p>
		<pre><code class="lang-c">
int invertRows(int i){
  return 0xB0 + i - 2 * (i - i % 0x10);
}

for(int i = 0; i &lt; 0xBC + 4; i++){
  if(i % 0x10 == 0) printf("\n");
  printf("%c ", (invertRows(i)-0x22)&amp;0x88 ? '-' : 'X');
}
		</code></pre>
		<p>Output:</p>
		<pre><code>
- - - - - - - - - - - - - - - -
- - - - - - - - - - - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - X X X X X X X X - - - - - -
- - - - - - - - - - - - - - - -
- - - - - - - - - - - - - - - -
		</code></pre>
		<p>The problem with printing out a board with A1 in the lower left corner is that the for loop will print starting at the top.  I therefore introduce the <code>invertRows</code> function that assumes a 16x12 board layout and converts an index to its corresponding index mirrored across the y axis.</p>
		<p>A few lines at the end of the <code>delta_init</code> function reveal the purpose of the extra 0x77:</p>
		<pre><code class="lang-c">
delta_vec[y+=k] = k;
if(j) capt_code[y] = m;
		</code></pre>
		<p>The memory addresses dedicated to <code>capt_code</code> are indexed by offsets between squares.  0x77 is the distance between the first and last squares (34 and 153), so the indices can be as low as -0x77 and as high as 0x77.  If you include the 0 index, this leaves a total of 0x77 * 2 + 1 = 0xEF addresses.  The same amount of memory is allocated for <code>delta_vec</code>, since the total size of brd is <code>brd[0xBC+2*0xEF+1]</code>.</p>
		<p>The next step is to print out <code>capt_code</code> and <code>delta_vec</code>.  First we initialize them like in the <code>delta_init</code> function, and then print the boards similarly to the game board above.</p>
		<p>TODO: complete this printout</p>
</main>
<!-- end of wrapper div -->
</div>
</body>
</html>
